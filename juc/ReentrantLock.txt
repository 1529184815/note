ReentrantLock 可重入锁
先判断是否是第一次 如果是第一次获取锁 设置当前线程拥有独占锁
后续线程到来 使用AQS的同步队列存储
第二次 判断是否是同一个线程 是 重入标志加1

公平锁
先进来的线程先获取
如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO
判断当前节点是否有前驱节点 有则获取锁失败

非公平锁
线程随意获取锁
刚释放的线程又能获取锁


1. 公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。
2. 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。

